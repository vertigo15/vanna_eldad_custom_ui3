"""Conversation history service for tracking text-to-SQL query lifecycle."""

import asyncpg
import logging
import json
from typing import Dict, Any, List, Optional
from uuid import UUID, uuid4
from datetime import datetime

logger = logging.getLogger(__name__)


class ConversationHistoryService:
    """
    Tracks complete query lifecycle: input ‚Üí LLM ‚Üí execution ‚Üí insights ‚Üí feedback.
    Enables conversation context, debugging, analytics, and ML training data.
    """
    
    def __init__(self, connection_string: str):
        """
        Initialize conversation history service.
        
        Args:
            connection_string: PostgreSQL connection string to history database
        """
        self.connection_string = connection_string
        self.pool: Optional[asyncpg.Pool] = None
    
    async def initialize(self):
        """Initialize database connection pool."""
        try:
            self.pool = await asyncpg.create_pool(
                self.connection_string,
                min_size=2,
                max_size=10
            )
            logger.info("‚úÖ Conversation history service initialized")
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize conversation history: {e}")
            raise
    
    async def close(self):
        """Close database connection pool."""
        if self.pool:
            await self.pool.close()
            logger.info("üëã Conversation history service closed")
    
    async def get_next_sequence_number(self, session_id: UUID) -> int:
        """
        Get next sequence number for a session.
        
        Args:
            session_id: Session UUID
            
        Returns:
            Next sequence number (1, 2, 3, ...)
        """
        async with self.pool.acquire() as conn:
            result = await conn.fetchval(
                "SELECT get_next_sequence_number($1)",
                session_id
            )
            return result
    
    async def log_query(
        self,
        user_id: str,
        session_id: UUID,
        natural_language_query: str,
        dataset_id: Optional[str] = None,
        schema_context: Optional[Dict[str, Any]] = None,
        rag_context: Optional[Dict[str, Any]] = None,
        parent_query_id: Optional[UUID] = None
    ) -> UUID:
        """
        Log initial query submission.
        
        Args:
            user_id: User identifier
            session_id: Session UUID for conversation grouping
            natural_language_query: User's question
            dataset_id: Which database/dataset
            schema_context: Snapshot of available tables/columns
            rag_context: RAG retrieval metadata (ddl_count, examples_count, scores)
            parent_query_id: Reference to previous query if follow-up
            
        Returns:
            query_id: UUID of the created query record
        """
        try:
            sequence_number = await self.get_next_sequence_number(session_id)
            
            async with self.pool.acquire() as conn:
                query_id = await conn.fetchval(
                    """
                    INSERT INTO txt2sql_conversation_sessions (
                        user_id, session_id, sequence_number, parent_query_id,
                        natural_language_query, dataset_id, schema_context, rag_context,
                        execution_status
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'pending')
                    RETURNING id
                    """,
                    user_id,
                    session_id,
                    sequence_number,
                    parent_query_id,
                    natural_language_query,
                    dataset_id,
                    json.dumps(schema_context) if schema_context else None,
                    json.dumps(rag_context) if rag_context else None
                )
                
                logger.info(f"üìù Logged query {query_id} for session {session_id} (seq {sequence_number})")
                return query_id
                
        except Exception as e:
            logger.error(f"‚ùå Failed to log query: {e}", exc_info=True)
            # Return a dummy UUID so flow continues
            return uuid4()
    
    async def update_llm_response(
        self,
        query_id: UUID,
        generated_sql: Optional[str],
        llm_model: str,
        llm_latency_ms: int,
        tokens_used: int
    ):
        """
        Update query record with LLM generation results.
        
        Args:
            query_id: Query UUID
            generated_sql: SQL generated by LLM
            llm_model: Model name (e.g., "gpt-4")
            llm_latency_ms: LLM response time
            tokens_used: Total tokens consumed
        """
        try:
            async with self.pool.acquire() as conn:
                await conn.execute(
                    """
                    UPDATE txt2sql_conversation_sessions
                    SET generated_sql = $1,
                        llm_model = $2,
                        llm_latency_ms = $3,
                        tokens_used = $4
                    WHERE id = $5
                    """,
                    generated_sql,
                    llm_model,
                    llm_latency_ms,
                    tokens_used,
                    query_id
                )
                logger.debug(f"Updated LLM response for query {query_id}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to update LLM response: {e}")
    
    async def update_execution(
        self,
        query_id: UUID,
        execution_status: str,
        execution_time_ms: Optional[int] = None,
        row_count: Optional[int] = None,
        result_preview: Optional[List[Dict[str, Any]]] = None,
        error_message: Optional[str] = None
    ):
        """
        Update query record with SQL execution results.
        
        Args:
            query_id: Query UUID
            execution_status: 'success', 'error', 'timeout', 'syntax_error'
            execution_time_ms: SQL execution time
            row_count: Number of rows returned
            result_preview: First 10 rows for reference
            error_message: Error details if failed
        """
        try:
            # Limit result preview to first 10 rows
            if result_preview and len(result_preview) > 10:
                result_preview = result_preview[:10]
            
            async with self.pool.acquire() as conn:
                await conn.execute(
                    """
                    UPDATE txt2sql_conversation_sessions
                    SET execution_status = $1,
                        execution_time_ms = $2,
                        row_count = $3,
                        result_preview = $4,
                        error_message = $5
                    WHERE id = $6
                    """,
                    execution_status,
                    execution_time_ms,
                    row_count,
                    json.dumps(result_preview) if result_preview else None,
                    error_message,
                    query_id
                )
                logger.debug(f"Updated execution results for query {query_id}: {execution_status}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to update execution: {e}")
    
    async def add_insight(
        self,
        query_id: UUID,
        insight_type: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
        llm_model: Optional[str] = None,
        llm_execution_time_ms: Optional[int] = None,
        tokens_input: Optional[int] = None,
        tokens_output: Optional[int] = None
    ) -> UUID:
        """
        Add an insight for a query.
        
        Args:
            query_id: Query UUID
            insight_type: 'summary', 'finding', 'suggestion', 'chart', 'anomaly'
            content: Insight text
            metadata: Additional structured data (chart configs, etc.)
            llm_model: Model used for insight generation
            llm_execution_time_ms: Time taken to generate insight
            tokens_input: Input tokens
            tokens_output: Output tokens
            
        Returns:
            insight_id: UUID of created insight
        """
        try:
            async with self.pool.acquire() as conn:
                insight_id = await conn.fetchval(
                    """
                    INSERT INTO txt2sql_query_insights (
                        query_id, insight_type, content, metadata,
                        llm_model, llm_execution_time_ms, tokens_input, tokens_output
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                    RETURNING id
                    """,
                    query_id,
                    insight_type,
                    content,
                    json.dumps(metadata) if metadata else None,
                    llm_model,
                    llm_execution_time_ms,
                    tokens_input,
                    tokens_output
                )
                logger.debug(f"Added {insight_type} insight {insight_id} for query {query_id}")
                return insight_id
                
        except Exception as e:
            logger.error(f"‚ùå Failed to add insight: {e}")
            return uuid4()
    
    async def record_feedback(
        self,
        query_id: UUID,
        user_feedback: str,
        corrected_sql: Optional[str] = None,
        feedback_notes: Optional[str] = None
    ):
        """
        Record user feedback for a query.
        
        Args:
            query_id: Query UUID
            user_feedback: 'thumbs_up', 'thumbs_down', 'edited'
            corrected_sql: User's corrected SQL if edited
            feedback_notes: Optional free-text notes
        """
        try:
            async with self.pool.acquire() as conn:
                await conn.execute(
                    """
                    UPDATE txt2sql_conversation_sessions
                    SET user_feedback = $1,
                        corrected_sql = $2,
                        feedback_notes = $3
                    WHERE id = $4
                    """,
                    user_feedback,
                    corrected_sql,
                    feedback_notes,
                    query_id
                )
                logger.info(f"üëçüëé Recorded {user_feedback} feedback for query {query_id}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to record feedback: {e}")
    
    async def get_conversation_context(
        self,
        session_id: UUID,
        limit: int = 5
    ) -> List[Dict[str, Any]]:
        """
        Get recent conversation history for context.
        
        Args:
            session_id: Session UUID
            limit: Number of recent queries to retrieve
            
        Returns:
            List of query dictionaries with sequence_number, query, sql, status
        """
        try:
            async with self.pool.acquire() as conn:
                rows = await conn.fetch(
                    """
                    SELECT 
                        sequence_number,
                        natural_language_query,
                        generated_sql,
                        execution_status,
                        created_at
                    FROM txt2sql_conversation_sessions
                    WHERE session_id = $1
                    ORDER BY sequence_number DESC
                    LIMIT $2
                    """,
                    session_id,
                    limit
                )
                
                return [dict(row) for row in rows]
                
        except Exception as e:
            logger.error(f"‚ùå Failed to get conversation context: {e}")
            return []
    
    async def get_conversation_history(
        self,
        session_id: UUID,
        include_insights: bool = True
    ) -> Dict[str, Any]:
        """
        Get complete conversation history with optional insights.
        
        Args:
            session_id: Session UUID
            include_insights: Whether to include insights for each query
            
        Returns:
            Dict with session metadata and queries list
        """
        try:
            async with self.pool.acquire() as conn:
                # Get all queries in session
                queries = await conn.fetch(
                    """
                    SELECT *
                    FROM txt2sql_conversation_sessions
                    WHERE session_id = $1
                    ORDER BY sequence_number ASC
                    """,
                    session_id
                )
                
                queries_list = []
                for query in queries:
                    query_dict = dict(query)
                    
                    # Get insights if requested
                    if include_insights:
                        insights = await conn.fetch(
                            """
                            SELECT insight_type, content, metadata, 
                                   llm_model, llm_execution_time_ms,
                                   tokens_input, tokens_output
                            FROM txt2sql_query_insights
                            WHERE query_id = $1
                            ORDER BY created_at ASC
                            """,
                            query_dict['id']
                        )
                        query_dict['insights'] = [dict(ins) for ins in insights]
                    
                    queries_list.append(query_dict)
                
                return {
                    "session_id": session_id,
                    "query_count": len(queries_list),
                    "queries": queries_list
                }
                
        except Exception as e:
            logger.error(f"‚ùå Failed to get conversation history: {e}")
            return {"session_id": session_id, "query_count": 0, "queries": []}
